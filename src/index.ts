import fs from "fs";
import { compile } from "json-schema-to-typescript";
import fetch from "node-fetch";
import path from "path";
import {
  API_KEY,
  apiEndpoint,
  cwd,
  ORGANIZATION_ID,
  SCHEMA_STRING_SUFFIX,
  targetDir,
} from "./common/config";
import { ErrorFetchingSnowplow } from "./common/errors";
import { exec } from "./common/exec";
import { colors } from "./common/systemColors";
import {
  ISchemaDescription,
  SnowplowSchemaDescriptions,
  SnowplowTokenResponse,
} from "./common/types";
import { capitalizeFirstLetter } from "./helpers/capitalizeFirstLetter";
import TemplateFile from "./transformer/templateFile";

const options = {
  bannerComment: `/**
 * This file was automatically generated by "yarn generateTrackingTypes".
 *
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema on:
 * https://console.snowplowanalytics.com/6995c3a4-3be7-43c8-b198-c81167e441a0/data-structures
 *
 * -> Afterwards, publish the new version and run "yarn generateTrackingTypes" again.
 */

$SCHEMA_STRING$`,
};

const generate = async () => {
  try {
    // Fetch schemas with Snowplow API
    console.log(`ðŸ¤– Fetch latest JSON schemas from ${apiEndpoint}..`);
    fetch(
      `${apiEndpoint}/api/msc/v1/organizations/${ORGANIZATION_ID}/credentials/v2/token`,
      {
        method: "GET",
        headers: {
          "X-API-Key": API_KEY,
        },
      }
    ).then(async (response) => {
      const token = (await response.json()) as SnowplowTokenResponse;
      if (token.accessToken) {
        console.log(`Got access token from credentials endpoint..`);
        fetch(
          `https://console.snowplowanalytics.com/api/msc/v1/organizations/${ORGANIZATION_ID}/data-structures/v1`,
          {
            method: "GET",
            headers: {
              authorization: `Bearer ${token.accessToken}`,
            },
          }
        ).then(async (response) => {
          const dataStructures =
            (await response.json()) as SnowplowSchemaDescriptions;
          console.log(
            `Received ${dataStructures.length} schema descriptions, get latest schema definitions..`
          );

          // Kill existing types folder
          fs.rmSync(`${targetDir}/events`, {
            recursive: true,
            force: true,
          });
          fs.rmSync(`${targetDir}/entities`, {
            recursive: true,
            force: true,
          });
          fs.mkdirSync(`${targetDir}/events`, { recursive: true });
          fs.mkdirSync(`${targetDir}/entities`, { recursive: true });

          // Get schema jsons of all structures
          const entitiesIndex: string[] = [];
          const eventsIndex: string[] = [];
          const entityTypeNames: string[] = [];
          const processDataStructures = dataStructures.map((ds) => {
            return new Promise((resolve: (value: unknown) => void) => {
              if (!ds.meta.hidden) {
                return fetchSchema(ds, token).then(
                  ({ relativeTargetPath, componentName }) => {
                    if (relativeTargetPath.startsWith("entities")) {
                      entitiesIndex.push(
                        `import { create${componentName} } from "./${relativeTargetPath
                          .split("/")[1]
                          .replace(".tsx", "")}";`
                      );
                      entitiesIndex.push(
                        `export type { ${componentName} } from "./${relativeTargetPath
                          .split("/")[1]
                          .replace(".tsx", "")}";`
                      );
                      entitiesIndex.push(
                        `export { ${componentName}${SCHEMA_STRING_SUFFIX} } from "./${relativeTargetPath
                          .split("/")[1]
                          .replace(".tsx", "")}";`
                      );
                      entitiesIndex.push(
                        `export { create${componentName}, TrackingContext${componentName} } from "./${relativeTargetPath
                          .split("/")[1]
                          .replace(".tsx", "")}";`
                      );
                      entityTypeNames.push(
                        `ReturnType<typeof create${componentName}>`
                      );
                    } else {
                      eventsIndex.push(
                        `export type { ${componentName} } from "./${relativeTargetPath
                          .split("/")[1]
                          .replace(".tsx", "")}";`
                      );
                      eventsIndex.push(
                        `export { ${componentName}${SCHEMA_STRING_SUFFIX} } from "./${relativeTargetPath
                          .split("/")[1]
                          .replace(".tsx", "")}";`
                      );
                      eventsIndex.push(
                        `export { track${componentName} } from "./${relativeTargetPath
                          .split("/")[1]
                          .replace(".tsx", "")}";`
                      );
                      eventsIndex.push(
                        `export { useTrack${componentName} } from "./${relativeTargetPath
                          .split("/")[1]
                          .replace(".tsx", "")}";`
                      );
                    }

                    resolve(true);
                  }
                );
              }
              resolve(true);
            });
          });
          Promise.all(processDataStructures).then((_) => {
            console.log("All files written, generate index files! ðŸ“");
            fs.writeFileSync(
              `${targetDir}/entities/index.ts`,
              entitiesIndex
                .sort((a, b) => {
                  if (a > b) {
                    return 1;
                  } else if (b > a) {
                    return -1;
                  }
                  return 0;
                })
                .join("\n") +
                `\nexport type TrackingEntities = ${entityTypeNames.join(
                  " | "
                )}`
            );

            fs.writeFileSync(
              `${targetDir}/events/index.ts`,
              eventsIndex
                .sort((a, b) => {
                  if (a > b) {
                    return 1;
                  } else if (b > a) {
                    return -1;
                  }
                  return 0;
                })
                .join("\n")
            );
            const mainIndexStr = `export * from "./entities";
export * from "./events";\n`;
            fs.writeFileSync(`${targetDir}/index.ts`, mainIndexStr);

            console.log("Finally run prettier! ðŸ’…");
            exec(`npx prettier --write "${targetDir}/**/*.{ts,tsx}"`, {
              cwd,
              printCommand: true,
              stdio: "inherit",
            });
          });
        });
      } else {
        console.error(`${colors.FgRed}${token.message}${colors.Reset}`);
      }
    });
  } catch (e) {
    console.error(e);
    throw new Error(ErrorFetchingSnowplow);
  }
};

const fetchSchema = async (
  ds: ISchemaDescription,
  token: SnowplowTokenResponse
) => {
  const latestDeployment = ds.deployments[0];
  const schemaType = ds.meta.schemaType;

  const schemaResponse = await fetch(
    `https://console.snowplowanalytics.com/api/msc/v1/organizations/${ORGANIZATION_ID}/data-structures/v1/${ds.hash}/versions/${latestDeployment.version}`,
    {
      method: "GET",
      headers: {
        authorization: `Bearer ${token.accessToken}`,
      },
    }
  );
  debugger;
  const schemaJson = (await schemaResponse.json()) as any;

  const componentName = `${capitalizeFirstLetter(
    snakeToCamel(schemaJson.self.name)
  )}${capitalizeFirstLetter(schemaType)}`;
  let schemaTs = await compile(schemaJson, componentName, options);

  const { file, imports } = writeFunctions(componentName, schemaType);
  const schemaString = `iglu:${ds.vendor}/${schemaJson.self.name}/jsonschema/${schemaJson.self.version}`;
  schemaTs = schemaTs
    .replace(
      "$SCHEMA_STRING$",
      `${
        imports ? `${imports}\n\n` : ""
      }export const ${componentName}${SCHEMA_STRING_SUFFIX} = "${schemaString}"`
    )
    .replace(/interface\s(\w+)\s{/i, "type $1 = {");

  const relativeTargetPath = `${
    schemaType === "event" ? "events" : "entities"
  }/${schemaJson.self.name}.generated.tsx`;

  const fns = file.getContent();
  fs.writeFileSync(`${targetDir}/${relativeTargetPath}`, `${schemaTs}\n${fns}`);

  console.log(
    `${colors.FgGreen}Write new type definition: ${relativeTargetPath}${colors.Reset}`
  );

  return { relativeTargetPath, componentName };
};

const snakeToCamel = (str: string) => {
  if (!/[_-]/.test(str)) {
    return str;
  }

  return str
    .toLowerCase()
    .replace(/([-_])([a-z])/g, (_match, _p1, p2) => p2.toUpperCase());
};

const writeFunctions = (componentName: string, schemaType: string) => {
  let file = new TemplateFile(
    `${componentName}`,
    "__eventFunctions__.txt",
    path.resolve(__dirname, "../src/transformer/templates"),
    targetDir,
    false
  );
  let imports = ``;
  if (schemaType === "event") {
    imports = `import {
      SelfDescribingJson,
      trackSelfDescribingEvent,
    } from "@snowplow/browser-tracker";
import { useSnowPlowTracking } from "../../context/tracking";`;
    file.updateContent((content) => {
      content = content.replace(/EVENT_TYPE_NAME/gi, componentName);
      content = content.replace(
        "EVENT_TYPE_SCHEMA_STRING",
        `${componentName}${SCHEMA_STRING_SUFFIX}`
      );

      return content;
    });
  } else {
    file = new TemplateFile(
      `${componentName}`,
      "__entityFunctions__.txt",
      path.resolve(__dirname, "../src/transformer/templates"),
      targetDir,
      false
    );
    imports = `import { FunctionComponent } from "react";
import { TrackingEntityContext } from "../../context/tracking";`;
    file.updateContent((content) => {
      content = content.replace(/ENTITY_TYPE_NAME/gi, componentName);
      content = content.replace(
        /ENTITY_TYPE_SCHEMA_STRING/gi,
        `${componentName}${SCHEMA_STRING_SUFFIX}`
      );

      return content;
    });
  }

  return {
    file,
    imports,
  };
};

generate();
